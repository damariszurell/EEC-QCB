<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Simple occupancy models</title>

<script src="site_libs/header-attrs-2.21/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.0/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.0/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Quantitative conservation biogeography</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Pracs: occupancy modelling
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Occ0_setup.html">0. Getting started</a>
    </li>
    <li>
      <a href="Occ1_SpatialData.html">1. Spatial data in R</a>
    </li>
    <li>
      <a href="Occ2_SpeciesData.html">2. Species data in R</a>
    </li>
    <li>
      <a href="Occ3_EnvData.html">3. Environmental data in R</a>
    </li>
    <li>
      <a href="Occ4_SimpleOccModel.html">4. Simple occupancy models</a>
    </li>
    <li>
      <a href="Occ5_EvalPred.html">5. Occupancy models: evaluation &amp; prediction</a>
    </li>
    <li>
      <a href="Occ6_DynamicOccModel.html">6. Dynamic occupancy models</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Pracs: population modelling
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="RS1_overview.html">1. Getting started with RangeShiftR</a>
    </li>
    <li>
      <a href="RS2_lynx.html">2. Eurasian lynx reintroduction</a>
    </li>
    <li>
      <a href="RS3_blackgrouse.html">3. Black grouse range dynamics</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://www.uni-potsdam.de/en/ibb-macroecology/index">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="https://twitter.com/ZurellLab">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Simple occupancy models</h1>

</div>


<hr />
<div class="alert alert-info">
<p><strong>RStudio project</strong></p>
<p>Open the RStudio project that we created in the previous session. I
recommend to use this RStudio project for the entire module and within
the RStudio project create separate R scripts for each session.</p>
<ul>
<li>Create a new empty R script by going to the tab “File”, select “New
File” and then “R script”</li>
<li>In the new R script, type
<code># Session Occ-4: Simple occupancy models</code> and save the file
in your folder “scripts” within your project folder, e.g. as
“Occ4_SimpleOccModel.R”</li>
</ul>
</div>
<div id="introduction" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>We have already heard that occupancy (or occupancy-detection) models
can deal with imperfect detection in species distribution modelling
<span class="citation">(Guillera-Arroita 2017; Kéry and Royle
2015)</span>. In the following, we will focus on false negative errors
(not recording a species although present) as these tend to be more
common in surveys than false positive errors (recording a species
although absent). Accounting for this imperfect detection requires a
hierarchical model structure in which we describe two separate
processes:</p>
<ul>
<li><p>the system or state process that represents the underlying
biological state, here the presence/absence of a species at site
<em>i</em>:</p>
<p><span class="math inline">\(z_i \sim
Bernoulli(\psi_i)\)</span></p></li>
<li><p>the observation process that describes the data observation or
collection, here the probability of observing a species during survey
<em>j</em> if the species is indeed present at site <em>i</em>:</p>
<p><span class="math inline">\(y_{ii}|z_i \sim
Bernoulli(z_i*p_{ij})\)</span></p></li>
</ul>
<p>where</p>
<p><span class="math inline">\(\psi_i\)</span> .. the probability of
occupancy (species presence) at site <em>i</em></p>
<p><span class="math inline">\(z_i\)</span> .. the true state of
occupancy of site <em>i</em></p>
<p><span class="math inline">\(p_{ij}\)</span> .. the detection
probability of the study species at site <em>i</em> during survey
<em>j</em></p>
<p><span class="math inline">\(y_{ij}\)</span> .. the observed data (our
observation of presence/absence) at site <em>i</em> during survey
<em>j</em></p>
<p>Thus, we want to predict the probability of detecting a species
conditional on the probability of occupancy of that species. Each
process can be described as a function of environmental covariates
(predictor variables). The site covariates describe how occupancy varies
across environmental gradients, the survey covariates describe how
detection varies across environmental gradients.</p>
<p>To tease apart the state process and the observation process, we need
information about how detections took place <span
class="citation">(Guillera-Arroita 2017)</span>. These typically stem
from repeat visits at a site (over time or by several observers), from
multiple independent detection methods, or from spatial subsampling. If
the species is observed (<span class="math inline">\(y=1\)</span>), then
also the true state of occupancy is a presence (<span
class="math inline">\(z=1\)</span>). However, if the species is not
observed (<span class="math inline">\(y=0\)</span>), the true state of
occupancy could be either a presence (<span
class="math inline">\(z=1\)</span>) but the species was simply not
observed (with probability of <span class="math inline">\(1-p\)</span>),
or the true state could indeed by an absence (<span
class="math inline">\(z=0\)</span>).</p>
<p>When repeat visits are undertaken, these should be close enough in
time to avoid any violation of the closure assumption. This assumes that
occupancy remains constant between the repeat visits, e.g. no emigration
or colonisation takes place over this time frame.</p>
<p>In this course, we will use two linked GLMs (generalised linear
models) to describe the state process and the observation process.</p>
<div id="generalised-linear-models-glms" class="section level2"
number="1.1">
<h2><span class="header-section-number">1.1</span> Generalised linear
models (GLMs)</h2>
<p>Generalised linear models (GLMs) are useful when our response
variable is not normally distributed. Remember that ordinary least
squares (OLS) linear regression assumes normally distributed data within
the ranges (<span class="math inline">\(-\infty,\infty\)</span>). OLS
regression looks like this</p>
<p><span class="math display">\[E(Y|X)=\beta X+\epsilon\]</span></p>
<p>where <span class="math inline">\(E(Y|X)\)</span> is the
<em>conditional mean</em>, meaning the expected value of the response
<span class="math inline">\(Y\)</span> given the environmental
predictors <span class="math inline">\(X\)</span> <span
class="citation">(Hosmer and Lemeshow 2013)</span>. <span
class="math inline">\(X\)</span> is the matrix of predictors (including
the intercept), <span class="math inline">\(\beta\)</span> are the
coefficients for the predictors, and <span
class="math inline">\(\epsilon\)</span> is the (normally distributed)
error term. <span class="math inline">\(\beta X\)</span> is referred to
as the linear predictor.</p>
<p>When we want to predict species occupancy based on environment, then
the conditional mean <span class="math inline">\(E(Y|X)\)</span> is
binary and bounded between 0 (absence) and 1 (presence). Thus, the
assumptions of OLS regression are not met. GLMs are more flexible
regression models that allow the response variable to follow other
distributions. Similar to OLS regression, we also fit a linear predictor
<span class="math inline">\(\beta X\)</span> and then relate this linear
predictor to the mean of the response variable using a link function.
The link function is used to transform the response to normality. In
case of a binary response, we typically use the logit link (or sometimes
the probit link). The conditional mean is then given by:</p>
<p><span class="math display">\[E(Y|X) = \pi (X) = \frac{e^{\beta
X+\epsilon}}{1+e^{\beta X+\epsilon}}\]</span></p>
<p>The logit transformation is defined as: <span
class="math display">\[g(X)  = ln \left( \frac{\pi (X)}{1-\pi (X)}
\right)   = \beta X+\epsilon\]</span></p>
<p>The trick is that the logit, g(X), is now linear in its parameters,
is continuous and may range (<span
class="math inline">\(-\infty,\infty\)</span>). GLMs with a logit link
are also called logistic regression models.</p>
</div>
</div>
<div id="the-simplest-occupancy-models-without-covariates"
class="section level1" number="2">
<h1><span class="header-section-number">2</span> The simplest occupancy
models (without covariates)</h1>
<p>We have already prepared a dataset with repeat observations for the
red kite in Practical 2. These data contain the observed
presence/absence of red kites in Spain in 5 km cells for the months
April to June.</p>
<pre class="r"><code># Load species data from Practical 2:
load(&#39;data/redkite_det_Esp_2022_wide.RData&#39;)

summary(redkite_det_Esp_2022_wide)</code></pre>
<pre><code>##       cell             x                y             month4      
##  Min.   : 2408   Min.   :-8.662   Min.   :36.05   Min.   :0.0000  
##  1st Qu.:15309   1st Qu.:-5.704   1st Qu.:38.92   1st Qu.:0.0000  
##  Median :27602   Median :-3.871   Median :40.50   Median :1.0000  
##  Mean   :28614   Mean   :-3.445   Mean   :40.38   Mean   :0.6649  
##  3rd Qu.:40414   3rd Qu.:-1.371   3rd Qu.:42.02   3rd Qu.:1.0000  
##  Max.   :63829   Max.   : 3.087   Max.   :43.59   Max.   :1.0000  
##      month5           month6      
##  Min.   :0.0000   Min.   :0.0000  
##  1st Qu.:0.0000   1st Qu.:0.0000  
##  Median :1.0000   Median :1.0000  
##  Mean   :0.6701   Mean   :0.6186  
##  3rd Qu.:1.0000   3rd Qu.:1.0000  
##  Max.   :1.0000   Max.   :1.0000</code></pre>
<p>We can get a naïve occupancy estimate for the red kite by simply
counting the number of 5 km cells where at least one presence was
recorded during the repeat visits and dividing by the total number of
sites surveyed:</p>
<pre class="r"><code># Naive occupancy estimate:
sum(apply(redkite_det_Esp_2022_wide[,4:6], 1, max)) / nrow(redkite_det_Esp_2022_wide)</code></pre>
<pre><code>## [1] 0.8865979</code></pre>
<p>The naïve estimate is that red kite occupy 89% of the sites. However,
due to false negatives (failure to detect the species although present)
the true occupancy might be underestimated.</p>
<p>To estimate the detection probability for the red kite and the true
occupancy probability, we use the <code>unmarked</code> package <span
class="citation">(Fiske and Chandler 2011)</span>. For this, we first
have to create an object of class <code>unmarkedFrameOccu</code></p>
<pre class="r"><code>library(unmarked)

# Create unmarked object containing the detection and non-detection data:
occ_redkite &lt;- unmarkedFrameOccu(y=redkite_det_Esp_2022_wide[,4:6])</code></pre>
<p>Next, we fit a single season occupancy model using the function
<code>occu()</code> in the <code>unmarked</code> package. This function
requires a double formula that specifies the survey and the site
covariates (predictor variables), first for the detection process and
second for the state (occupancy) process:
<code>occu(~survey covariates ~site covariates)</code>. Here, we will
not add any survey or site covariates, meaning that we simply estimate a
null model:</p>
<pre class="r"><code># Fitting simple single season occupancy models without survey or site covariates (intercept model):
m_occ_null &lt;- occu(~1 ~ 1, occ_redkite)

# Summarise model output:
summary(m_occ_null)</code></pre>
<pre><code>## 
## Call:
## occu(formula = ~1 ~ 1, data = occ_redkite)
## 
## Occupancy (logit-scale):
##  Estimate    SE    z  P(&gt;|z|)
##      2.28 0.199 11.4 2.87e-30
## 
## Detection (logit-scale):
##  Estimate     SE    z  P(&gt;|z|)
##     0.935 0.0753 12.4 2.29e-35
## 
## AIC: 1458.679 
## Number of sites: 388
## optim convergence code: 0
## optim iterations: 48 
## Bootstrap iterations: 0</code></pre>
<p>The estimates for the occupancy probability and the detection
probability are provided at logit scale and we need to back transform
them to get probability estimates between 0 and 1.</p>
<pre class="r"><code># Get detection probability estimate:
(p_det &lt;- backTransform(m_occ_null, &quot;det&quot;))</code></pre>
<pre><code>## Backtransformed linear combination(s) of Detection estimate(s)
## 
##  Estimate     SE LinComb (Intercept)
##     0.718 0.0152   0.935           1
## 
## Transformation: logistic</code></pre>
<pre class="r"><code># Get occupancy probability estimate:
(p_psi &lt;- backTransform(m_occ_null, &quot;state&quot;))</code></pre>
<pre><code>## Backtransformed linear combination(s) of Occupancy estimate(s)
## 
##  Estimate     SE LinComb (Intercept)
##     0.907 0.0168    2.28           1
## 
## Transformation: logistic</code></pre>
<p>We see that our detection probability is rather high at 72% and
indeed our estimated occupancy probability is 91% and thus close to our
naïve estimate of 89%.</p>
</div>
<div id="simple-occupancy-models-with-covariates" class="section level1"
number="3">
<h1><span class="header-section-number">3</span> Simple occupancy models
with covariates</h1>
<p>Most of the time we are probably more interested in how far site
covariates affect occupancy probability or even in how far survey
covariates affect detection probability. In practical Occ-3, we have
already extracted environmental data for our survey data set. Now, we
want to add this environmental information to our occupancy-detection
model to explain how occupancy (or detection) varies across
environmental gradients.</p>
<div id="adding-site-covariates" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Adding site
covariates</h2>
<p>In our first set of models, we assume that detection probability is
constant in space and only test the effect of different site covariates
in occupancy. For simplicity, we focus only on two site covariates
(<em>bio1</em> = mean annual temperature, and <em>tree cover</em>).
Later, we will learn how deal with multiple site (or survey)
covariates.</p>
<p>We first load our data set containing both detection data and
environmental variables and create an <code>unmarked</code> data
object.</p>
<pre class="r"><code># Load species data from Practical 3:
load(&#39;data/redkite_det_env_Esp_2022.RData&#39;)

head(redkite_det_env_Esp_2022)</code></pre>
<pre><code>##    cell         x        y month4 month5 month6 ID ESP_elv    bio_1     bio_2
## 1 52971 -5.995833 37.37917      1      1      1  1   11.96 18.62383 11.624333
## 2 28278 -3.745833 40.42083      1      1      1  2  627.32 14.45633 11.036667
## 3 53647 -6.079167 37.29583      1      1      1  3   27.56 18.14633 11.877333
## 4 58731 -6.120833 36.67083      1      1      1  4   34.08 17.94817  9.913667
## 5 27941 -3.662500 40.46250      1      1      0  5  715.32 14.03783 10.963667
## 6 54322 -6.204167 37.21250      1      1      1  6   11.16 17.96250 11.380333
##      bio_3    bio_4  bio_5 bio_6  bio_7     bio_8    bio_9   bio_10   bio_11
## 1 41.09237 588.1969 34.452 6.164 28.288 12.606667 26.03933 26.18200 11.78667
## 2 36.74473 680.4317 31.768 1.732 30.036 10.330000 23.36600 23.36600  6.77200
## 3 41.94698 576.6686 34.084 5.768 28.316 12.310000 25.41333 25.56267 11.45000
## 4 40.85036 509.7639 31.368 7.100 24.268 12.980667 24.23400 24.63333 12.08800
## 5 36.62693 680.0941 31.348 1.416 29.932  9.904667 22.95333 22.95333  6.38000
## 6 42.20560 548.9442 32.964 6.000 26.964 12.456000 24.81667 25.03133 11.57200
##   bio_12 bio_13 bio_14   bio_15 bio_16 bio_17 bio_18 bio_19    trees
## 1 536.20  93.72   2.00 67.06034 252.28  22.20  27.12 223.76 0.088260
## 2 397.36  50.52  10.00 41.05074 144.00  47.32  47.32 119.16 0.525668
## 3 537.08  93.84   2.00 66.61317 252.08  22.92  27.04 224.84 0.084180
## 4 581.84 102.36   1.00 69.60263 279.48  20.48  23.08 253.96 0.068260
## 5 425.24  55.68  10.88 41.12534 155.56  49.76  49.76 126.56 0.191820
## 6 522.16  92.16   2.00 68.17232 248.60  21.16  25.00 222.12 0.257988</code></pre>
<!-- ```{r echo=F} -->
<!-- # Load species data from Practical 3: -->
<!-- load('data/redkite_det_env_Esp_2022_v2.RData') -->
<!-- redkite_det_env_Esp_2022 <- redkite_det_env_Esp_2022_v2 -->
<!-- head(redkite_det_env_Esp_2022) -->
<!-- ``` -->
<p>To help stabilize the numerical optimisation algorithm, we recommend
standardising the covariates. This can easily be done using the base
function <code>scale()</code>.</p>
<pre class="r"><code># Standardise all covariates to have a mean=0 and standard deviation sd=1:
redkite_det_env_Esp_2022[,-c(1:7)] &lt;- scale(redkite_det_env_Esp_2022[,-c(1:7)])

# Create unmarked object containing the detection and non-detection data and the covariate data:
occ_env_redkite &lt;- unmarkedFrameOccu(y = redkite_det_env_Esp_2022[,4:6], siteCovs = redkite_det_env_Esp_2022[,-c(1:7)])</code></pre>
<p>We use the same method as we did for our null model only that we now
add the name(s) of site covariates to the formula (the names are the
column names of our data set). Remember that the formula in the
<code>occu()</code> function of <code>unmarked</code> takes the form:
<code>occu(~survey covariates ~site covariates)</code>.</p>
<pre class="r"><code># Fitting simple single season occupancy models without survey or site covariates (intercept model):
m_occ_bio1 &lt;- occu(~1 ~ bio_1, occ_env_redkite)

# Summarise model output:
summary(m_occ_bio1)</code></pre>
<pre><code>## 
## Call:
## occu(formula = ~1 ~ bio_1, data = occ_env_redkite)
## 
## Occupancy (logit-scale):
##             Estimate    SE      z  P(&gt;|z|)
## (Intercept)    2.286 0.202 11.297 1.35e-29
## bio_1         -0.149 0.222 -0.671 5.02e-01
## 
## Detection (logit-scale):
##  Estimate     SE    z P(&gt;|z|)
##     0.934 0.0754 12.4 2.6e-35
## 
## AIC: 1460.192 
## Number of sites: 388
## optim convergence code: 0
## optim iterations: 35 
## Bootstrap iterations: 0</code></pre>
<p>We can also fit quadratic or higher polynomial terms (check
<code>?poly</code>) and interactions between predictors:<br />
- the term <code>I()</code>indicates that a variable should be
transformed before being used as predictor in the formula<br />
- <code>poly(x,n)</code> creates a polynomial of degree <span
class="math inline">\(n\)</span>: <span class="math inline">\(x + x^2 +
... + x^n\)</span><br />
- <code>x1:x2</code> creates a two-way interaction term between
variables x1 and x2, the linear terms of x1 and x2 would have to be
specified separately<br />
- <code>x1*x2</code> creates a two-way interaction term between
variables x1 and x2 plus their linear terms</p>
<p>Let’s play with these notations a little bit.</p>
<pre class="r"><code># Add quadratic term:
occu(~1 ~ bio_1 + I(bio_1^2), occ_env_redkite)</code></pre>
<pre><code>## 
## Call:
## occu(formula = ~1 ~ bio_1 + I(bio_1^2), data = occ_env_redkite)
## 
## Occupancy:
##             Estimate    SE     z  P(&gt;|z|)
## (Intercept)     2.84 0.655  4.33 1.48e-05
## bio_1          -3.82 2.066 -1.85 6.46e-02
## I(bio_1^2)      2.79 1.422  1.96 5.00e-02
## 
## Detection:
##  Estimate     SE  z  P(&gt;|z|)
##     0.859 0.0714 12 2.31e-33
## 
## AIC: 1462.95</code></pre>
<pre class="r"><code># Add quadratic term using poly():
occu(~1 ~ poly(bio_1, degree=2, raw=T), occ_env_redkite)</code></pre>
<pre><code>## 
## Call:
## occu(formula = ~1 ~ poly(bio_1, degree = 2, raw = T), data = occ_env_redkite)
## 
## Occupancy:
##                                   Estimate    SE     z  P(&gt;|z|)
## (Intercept)                           2.84 0.655  4.33 1.48e-05
## poly(bio_1, degree = 2, raw = T)1    -3.82 2.066 -1.85 6.46e-02
## poly(bio_1, degree = 2, raw = T)2     2.79 1.422  1.96 5.00e-02
## 
## Detection:
##  Estimate     SE  z  P(&gt;|z|)
##     0.859 0.0714 12 2.31e-33
## 
## AIC: 1462.95</code></pre>
<pre class="r"><code># Add another covariate:
occu(~1 ~ bio_1 + trees, occ_env_redkite)</code></pre>
<pre><code>## 
## Call:
## occu(formula = ~1 ~ bio_1 + trees, data = occ_env_redkite)
## 
## Occupancy:
##             Estimate    SE      z  P(&gt;|z|)
## (Intercept)    2.296 0.206 11.139 8.07e-29
## bio_1         -0.119 0.229 -0.521 6.02e-01
## trees          0.145 0.227  0.640 5.22e-01
## 
## Detection:
##  Estimate     SE    z  P(&gt;|z|)
##     0.934 0.0754 12.4 3.01e-35
## 
## AIC: 1461.749</code></pre>
<pre class="r"><code># Add quadratic terms for both covariates:
occu(~1 ~ bio_1 + I(bio_1^2) + trees + I(trees^2), occ_env_redkite)</code></pre>
<pre><code>## 
## Call:
## occu(formula = ~1 ~ bio_1 + I(bio_1^2) + trees + I(trees^2), 
##     data = occ_env_redkite)
## 
## Occupancy:
##             Estimate    SE      z  P(&gt;|z|)
## (Intercept)    2.806 0.707  3.968 7.24e-05
## bio_1         -3.922 2.140 -1.833 6.68e-02
## I(bio_1^2)     2.915 1.465  1.990 4.66e-02
## trees          0.231 0.397  0.581 5.61e-01
## I(trees^2)     0.156 0.422  0.370 7.12e-01
## 
## Detection:
##  Estimate     SE  z  P(&gt;|z|)
##     0.856 0.0716 12 6.12e-33
## 
## AIC: 1465.713</code></pre>
<p>Finally, let’s add a covariate to assess how detection probability
varies with elevation. Note that this variable is also part of our site
covariates in the <code>unmarkedFrameOccu</code> object. This has the
simple reason that this variable does not vary across repeated surveys
as would e.g. be the case for wind data. We can nevertheless also use
those covariates that are constant across all surveys to explain spatial
variation in detection probability.</p>
<pre class="r"><code>(m_occdet_bio1q_treesq &lt;- occu(~ESP_elv ~ bio_1 + I(bio_1^2) + trees + I(trees^2), occ_env_redkite))</code></pre>
<pre><code>## 
## Call:
## occu(formula = ~ESP_elv ~ bio_1 + I(bio_1^2) + trees + I(trees^2), 
##     data = occ_env_redkite)
## 
## Occupancy:
##             Estimate    SE      z  P(&gt;|z|)
## (Intercept)   2.7974 0.669  4.179 2.93e-05
## bio_1        -3.8874 1.969 -1.974 4.84e-02
## I(bio_1^2)    2.8314 1.338  2.116 3.44e-02
## trees         0.2093 0.368  0.569 5.70e-01
## I(trees^2)    0.0944 0.301  0.314 7.53e-01
## 
## Detection:
##             Estimate     SE     z  P(&gt;|z|)
## (Intercept)    0.891 0.0723 12.33 6.64e-35
## ESP_elv       -0.236 0.0657 -3.59 3.26e-04
## 
## AIC: 1454.919</code></pre>
</div>
<div id="model-comparison-and-selection" class="section level2"
number="3.2">
<h2><span class="header-section-number">3.2</span> Model comparison and
selection</h2>
<p>But how to decide which model best explains the observed data? A
useful statistic is the AIC, the <em>Akaike information criterion</em>,
which is part of the standard output of the <code>unmarked</code>
models. It is based on the deviance and thus conveys information about
how closely the model fits the data. It is calculated from the
log-likelihood <span class="math inline">\(L\)</span> and penalises for
the number of parameters <span class="math inline">\(p\)</span>
(regression coefficients) in the model:</p>
<p><span class="math display">\[AIC = -2 \times L + 2 \times
(p+1)\]</span> AIC thus takes into account model complexity. In general,
lower values of AIC are preferable. But caution, AIC cannot be
interpreted in absolute terms and cannot be compared between different
data sets. It can, however, provide a meaningful way to compare
different candidate models for the same data set.</p>
<p>We can simply extract the AIC from the model objects.</p>
<pre class="r"><code># Extract AIC
m_occ_bio1@AIC</code></pre>
<pre><code>## [1] 1460.192</code></pre>
<pre class="r"><code>m_occdet_bio1q_treesq@AIC</code></pre>
<pre><code>## [1] 1454.919</code></pre>
<p>The <code>unmarked</code> package also contains a function
<code>modSel()</code> function for computing AIC-based model selection.
For this, we have to provide a list of models to compare. Let’s
systematically compare the different predictor variables to explain
occupancy and detection. To do so, we have to add all candidate models
to a <code>fitList</code> object. Note that all models in the list have
to be based on the same data frame. We thus also have to refit our null
model.</p>
<pre class="r"><code># Collect the candidate models in a named list. Try to use meaningful names of the models
cand_models &lt;- fitList(
  &quot;p(1) psi(1)&quot; = occu(~1 ~ 1, occ_env_redkite),
  &quot;p(1) psi(bio1)&quot; = occu(~1 ~ bio_1, occ_env_redkite),
  &quot;p(1) psi(bio1.sqr)&quot; = occu(~1 ~ bio_1 + I(bio_1^2), occ_env_redkite),
  &quot;p(1) psi(trees)&quot; = occu(~1 ~ trees, occ_env_redkite),
  &quot;p(1) psi(trees.sqr)&quot; = occu(~1 ~ trees + I(trees^2), occ_env_redkite),
  &quot;p(1) psi(bio1 + trees)&quot; = occu(~1 ~ bio_1 + trees, occ_env_redkite),
  &quot;p(1) psi(bio1.sqr + trees)&quot; = occu(~1 ~ bio_1 + I(bio_1^2) + trees, occ_env_redkite),
  &quot;p(1) psi(bio1.sqr + trees.sqr)&quot; = occu(~1 ~ bio_1 +I(bio_1^2) + trees + I(trees^2), occ_env_redkite),
  &quot;p(elev) psi(1)&quot; = occu(~ESP_elv ~ 1, occ_env_redkite),
  &quot;p(elev) psi(bio1)&quot; = occu(~ESP_elv ~ bio_1, occ_env_redkite),
  &quot;p(elev) psi(bio1.sqr)&quot; = occu(~ESP_elv ~ bio_1 + I(bio_1^2), occ_env_redkite),
  &quot;p(elev) psi(trees)&quot; = occu(~ESP_elv ~ trees, occ_env_redkite),
  &quot;p(elev) psi(trees.sqr)&quot; = occu(~ESP_elv ~ trees + I(trees^2), occ_env_redkite),
  &quot;p(elev) psi(bio1 + trees)&quot; = occu(~ESP_elv ~ bio_1 + trees, occ_env_redkite),
  &quot;p(elev) psi(bio1.sqr + trees)&quot; = occu(~ESP_elv ~ bio_1 + I(bio_1^2) + trees, occ_env_redkite),
  &quot;p(elev) psi(bio1.sqr + trees.sqr)&quot; = occu(~ESP_elv ~ bio_1 +I(bio_1^2) + trees + I(trees^2), occ_env_redkite)
)

# Compute the summary output for model selection. When explicitly stating which candidate model refers is the null model, then a Nagelkerke R-square is computed.
(m_sel &lt;- modSel(cand_models, nullmod=&quot;p(1) psi(1)&quot;))</code></pre>
<pre><code>##                                   nPars     AIC delta   AICwt cumltvWt      Rsq
## p(elev) psi(bio1.sqr)                 5 1451.96  0.00 0.45849     0.46  0.03303
## p(elev) psi(bio1.sqr + trees)         6 1453.03  1.07 0.26787     0.73  0.03539
## p(elev) psi(bio1.sqr + trees.sqr)     7 1454.92  2.96 0.10440     0.83  0.03568
## p(elev) psi(1)                        3 1456.93  4.97 0.03823     0.87  0.00985
## p(elev) psi(bio1)                     4 1456.95  4.99 0.03777     0.91  0.01501
## p(elev) psi(trees)                    4 1457.95  5.99 0.02296     0.93  0.01241
## p(elev) psi(bio1 + trees)             5 1458.29  6.33 0.01934     0.95  0.01672
## p(1) psi(1)                           2 1458.68  6.72 0.01593     0.96  0.00000
## p(elev) psi(trees.sqr)                5 1459.75  7.79 0.00933     0.97  0.01293
## p(1) psi(trees)                       3 1460.04  8.08 0.00808     0.98  0.00169
## p(1) psi(bio1)                        3 1460.19  8.23 0.00748     0.99  0.00129
## p(1) psi(bio1 + trees)                4 1461.75  9.79 0.00343     0.99  0.00245
## p(1) psi(trees.sqr)                   4 1461.90  9.94 0.00318     1.00  0.00205
## p(1) psi(bio1.sqr)                    4 1462.95 10.99 0.00188     1.00 -0.00071
## p(1) psi(bio1.sqr + trees)            5 1463.92 11.96 0.00116     1.00  0.00201
## p(1) psi(bio1.sqr + trees.sqr)        6 1465.71 13.75 0.00047     1.00  0.00255</code></pre>
<p>The output provides different useful summary statistics.</p>
<ul>
<li><code>delta</code> refers to the <span class="math inline">\(\Delta
AIC\)</span> and is the difference in AIC between different models,
relative to the smallest AIC found in the candidate model set, meaning
relative to the best model. When the number of candidate models is
reasonably small, the <span class="math inline">\(\Delta AIC\)</span>
can be interpreted straightforwardly. A <span
class="math inline">\(\Delta AIC\)</span> between 0 and 2 indicates
substantial support for the candidate models, meaning they are
essentially as good as the best model, while values between 4-7 indicate
considerably less support compared to the best model, and a value
greater than 10 indicates no support for the candidate model <span
class="citation">(Burnham and Anderson 2002)</span>.</li>
<li><code>AICwt</code> refers to the <em>Akaike weight</em>, which is
the relative likelihood of a model compared to all other models in the
candidate model set. These weights are normalised to sum to 1 and are
typically interpreted as probability that the model is the best
performing <span class="citation">(Burnham and Anderson
2002)</span>.</li>
<li><code>cumltvWt</code> refers to the cumulative Akaike weights from
top to bottom.</li>
<li><code>Rsq</code> is computed when the null model is specified in the
<code>modSel()</code> function and is the Nagelkerke <span
class="math inline">\(R_{N}^{2}\)</span>, generalization of the
coefficient of determination <span class="math inline">\(R^2\)</span>
<span class="citation">(Nagelkerke 1991)</span>. Typically, <span
class="math inline">\(R^2\)</span> values in logistic regression are
rather low <span class="citation">(Hosmer and Lemeshow
2013)</span>.</li>
</ul>
</div>
<div id="multicollinearity" class="section level2" number="3.3">
<h2><span class="header-section-number">3.3</span>
Multicollinearity</h2>
<p>GLMs (and many other statistical models) have problems to fit stable
parameters if two or more predictor variables are highly correlated,
resulting in so-called multicollinearity issues <span
class="citation">(Dormann et al. 2013)</span>. Thus, before we can add
more covariates to our models, we need to check for multi-collinearity
and select an initical set of covariates that are only weakly
correlated. Then, we can fit our occupancy models including multiple
predictors and with differently complex response shapes. This model can
then be further simplified by removing “unimportant” predictors.</p>
<p>Different approaches exist for quantifying and removing collinearity
<span class="citation">(Dormann et al. 2013)</span>, and we here only
introduce a single, simple and pragmatic yet efficient approach based on
pairwise correlation.</p>
<p>We first check for pairwise correlations among predictors. Generally,
correlations below |r|&lt;0.7 are considered unproblematic (or below
|r|&lt;0.5 as more conservative threshold).</p>
<pre class="r"><code>library(corrplot)

# We first estimate a correlation matrix from the covariates 
# We use Spearman rank correlation coefficient, as we do not know 
# whether all variables are normally distributed.
cor_mat &lt;- cor(occ_env_redkite@siteCovs, method=&#39;spearman&#39;)

# We can visualise this correlation matrix. For better visibility, 
# we plot the correlation coefficients as percentages.
corrplot.mixed(cor_mat, tl.pos=&#39;lt&#39;, tl.cex=0.6, number.cex=0.5, addCoefasPercent=T)</code></pre>
<p><img src="Occ4_SimpleOccModel_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>If no prior knowledge is available on the importance of different
predictors, then <span class="citation">Dormann et al. (2013)</span>
suggest to assess univariate variable importance in terms of AIC (Akaike
information criterion) or explained deviance. In practice, this means
that we fit separate occupancy-detection models for each predictor,
assess the importance of the predictor in terms of AIC and then rank the
variables according to their univariate importance. To do so, we first
need to identify all pairs of variables that have correlation |r|&gt;0.7
and remove the less important variable. <span class="citation">Dormann
et al. (2013)</span> call this the <em>select07</em> method.</p>
<p>A <code>select07_unm()</code> function is implemented in the package
<code>mecofun</code> along with some other useful functions for
teaching. We first have to install the package from the Univ. Potsdam
gitlab:</p>
<pre class="r"><code>library(devtools)
devtools::install_git(&quot;https://gitup.uni-potsdam.de/macroecology/mecofun.git&quot;)</code></pre>
<p>Now, you can load the package and try out the function. Also, check
out the help pages for <code>?select07_unm</code>.</p>
<pre class="r"><code>library(mecofun)

# Run select07()
var_sel &lt;- select07_unm(occ_env_redkite, names(occ_env_redkite@siteCovs), threshold=0.7)

# Check out the structure of the resulting object:
str(var_sel)</code></pre>
<pre><code>## List of 3
##  $ AIC     : Named num [1:21] 1460 1460 1460 1460 1460 ...
##   ..- attr(*, &quot;names&quot;)= chr [1:21] &quot;bio_15&quot; &quot;bio_14&quot; &quot;bio_10&quot; &quot;bio_18&quot; ...
##  $ cor_mat : num [1:21, 1:21] 1 -0.859 0.129 -0.412 0.475 ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : chr [1:21] &quot;ESP_elv&quot; &quot;bio_1&quot; &quot;bio_2&quot; &quot;bio_3&quot; ...
##   .. ..$ : chr [1:21] &quot;ESP_elv&quot; &quot;bio_1&quot; &quot;bio_2&quot; &quot;bio_3&quot; ...
##  $ pred_sel: chr [1:9] &quot;bio_15&quot; &quot;bio_10&quot; &quot;trees&quot; &quot;bio_12&quot; ...</code></pre>
<pre class="r"><code># We extract the names of the weakly correlated predictors ordered by the univariate variable importance in terms of AIC:
pred_sel &lt;- var_sel$pred_sel</code></pre>
<p>So, we have now reduced our set of covariates that are only weakly
correlated. Now, we need to decide whether all of the remaining should
be included in the final model, or if we select only a few, for example
the two most important variables in terms of univariate AIC. As a rule
of thumb, we should have ten observations (presence sites or absence
sites) per covariate that is included in the model <span
class="citation">(Guisan, Thuiller, and Zimmermann 2017)</span>.</p>
<pre class="r"><code># Number of presences
sum(apply(redkite_det_env_Esp_2022[,4:6], 1, max))</code></pre>
<pre><code>## [1] 344</code></pre>
<pre class="r"><code># Number of absence
nrow(redkite_det_env_Esp_2022) - sum(apply(redkite_det_env_Esp_2022[,4:6], 1, max))</code></pre>
<pre><code>## [1] 44</code></pre>
<p>In our case, we have comparably few absence site, which will thus be
the limiting number.</p>
<div class="alert alert-info">
<p><em><strong>Exercise:</strong></em></p>
<ul>
<li>Have you downloaded any other land cover data in the previous
tutorial? Then also try these out. For example, grassland might be more
important for the red kite than tree cover.</li>
<li>Define a full model with the weakly correlated variables including
their linear and quadratic terms. Adhere to the rule of thumb for the
number of covariates allowed in the model.</li>
<li>Compile a set of candidate models and run a model comparison.</li>
<li>Repeat the steps with your own species data that you compiled in
Practical Occ-2.</li>
</ul>
</div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-burnham2002" class="csl-entry">
Burnham, Kenneth P., and David R. Anderson. 2002. <em>Model Selection
and Multi-Model Inference: A Practical Information-Theoretic
Approach</em>. 2nd ed. Springer.
</div>
<div id="ref-Dormann2013" class="csl-entry">
Dormann, Carsten F., Jane Elith, Sven Bacher, Carsten Buchmann, Gudrun
Carl, Gabriel Carré, Jaime R. García Marquéz, et al. 2013.
<span>“Collinearity: A Review of Methods to Deal with It and a
Simulation Study Evaluating Their Performance.”</span>
<em>Ecography</em> 36 (1): 27–46. <a
href="https://doi.org/10.1111/j.1600-0587.2012.07348.x">https://doi.org/10.1111/j.1600-0587.2012.07348.x</a>.
</div>
<div id="ref-unmarked2011" class="csl-entry">
Fiske, Ian, and Richard Chandler. 2011. <span>“<span
class="nocase">unmarked</span>: An <span>R</span> Package for Fitting
Hierarchical Models of Wildlife Occurrence and Abundance.”</span>
<em>Journal of Statistical Software</em> 43 (10): 1–23. <a
href="https://www.jstatsoft.org/v43/i10/">https://www.jstatsoft.org/v43/i10/</a>.
</div>
<div id="ref-Guillera-Arroita2017" class="csl-entry">
Guillera-Arroita, Gurutzeta. 2017. <span>“Modelling of Species
Distributions, Range Dynamics and Communities Under Imperfect Detection:
Advances, Challenges and Opportunities.”</span> <em>Ecography</em> 40
(2): 281–95. <a
href="https://doi.org/10.1111/ecog.02445">https://doi.org/10.1111/ecog.02445</a>.
</div>
<div id="ref-Guisan2017" class="csl-entry">
Guisan, Antoine, Wilfried Thuiller, and Niklaus E. Zimmermann. 2017.
<em>Habitat Suitability and Distribution Models with Applications in
r</em>. Cambride University Press.
</div>
<div id="ref-Hosmer2013" class="csl-entry">
Hosmer, David W., and Stanley Lemeshow. 2013. <em>Applied Logistic
Regression</em>. 3rd ed. John Wiley &amp; Sons, Inc.
</div>
<div id="ref-Kery2015" class="csl-entry">
Kéry, Marc, and J. Andrew Royle. 2015. <em>Applied Hierarchical Modeling
in Ecology: Analysis of Distribution, Abundance and Species Richness in
r and BUGS</em>. Elsevier.
</div>
<div id="ref-nagelkerke1991" class="csl-entry">
Nagelkerke, N. J. D. 1991. <span>“A Note on a General Definition of the
Coefficient of Determination.”</span> <em>Biometrika</em> 78: 691–92.
</div>
</div>
</div>

<!DOCTYPE html>
<html>

<br>
<hr />
<div id="footer">
<p>Damaris Zurell, Guillermo Fandos, Anne-Kathleen Malchow, Jette Reeg 2021-2023 <a href="http://creativecommons.org/licenses/by/4.0/" >(CC BY 4.0)</a>.  </p>
</div>

</html>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Black grouse range dynamics</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/anchor-sections-1.0/anchor-sections.css" rel="stylesheet" />
<script src="site_libs/anchor-sections-1.0/anchor-sections.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Quantitative conservation biogeography</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="schedule.html">Schedule</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Pracs: occupancy modelling
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Under construction</li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Pracs: population modelling
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="RS0_installing.html">0. Installing RangeShiftR</a>
    </li>
    <li>
      <a href="RS1_overview.html">1. Getting started with RangeShiftR</a>
    </li>
    <li>
      <a href="RS2_blackgrouse.html">2. Black grouse range dynamics</a>
    </li>
    <li>
      <a href="RS3_lynx.html">3. Eurasian lynx reintroduction</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://www.uni-potsdam.de/en/ibb-macroecology/index">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="https://twitter.com/ZurellLab">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Black grouse range dynamics</h1>

</div>


<p><img src="figures/blackgrouse.png" width="50%" /></p>
<p>This practical shows how spatially-explicit population models or spatially-explicit individual-based models like <code>RangeShiftR</code> <span class="citation">(Bocedi et al. 2014, 2020; Malchow et al. 2020)</span> can be used for simulating species range dynamics under scenarios of global change. We illustrate this by re-implementing the black grouse model introduced by <span class="citation">Zurell et al. (2012)</span>. Specifically, we will simulate extinction risks and climate change-induced range dynamics of black grouse (<em>Lyrurus tetrix</em>) in Switzerland, and run a (very slim) sensitivity analysis to assess how model predictions are affected by changes in the underlying parameters. The original black grouse individual-based model was not based on RangeShifter but was implemented from scratch. To accomodate the simulations in <code>RangeShiftR</code>, we have to adapt some modelling decisions.</p>
<div class="alert alert-info">
<p><strong>RStudio project</strong></p>
<p>Open the RStudio project that we created in the first session. We recommend to use this RStudio project for the entire course and within the RStudio project create separate R scripts for each session.</p>
<ul>
<li>Create a new empty R script by going to the tab “File”, select “New File” and then “R script”</li>
<li>In the new R script, type <code># Session 2: black grouse range dynamics</code> and save the file in your folder “scripts” within your project folder, e.g. as “2_blackgrouse.R”</li>
</ul>
</div>
<div id="black-grouse-model" class="section level1">
<h1><span class="header-section-number">1</span> Black grouse model</h1>
<p>First, we set up all the parameters modules that we need to run a <code>RangeShiftR</code> simulation (see schematic figure in Practical 1).</p>
<div id="set-up-directories-and-data" class="section level2">
<h2><span class="header-section-number">1.1</span> Set up directories and data</h2>
<p>We need to set up the folder structure again with a folder containing the models of this practical and the three sub-folders named ‘Inputs’, ‘Outputs’ and ‘Output_Maps’. To do so, use your file explorer on your machine, navigate to the “models” folder within your project, and create a sub-folder for the current practical, e.g. “BlackGrouse”. Next, return to your RStudio project and store the path in a variable. This can either be the relative path from your R working directory or the absolute path.</p>
<pre class="r"><code># load required packages
library(RangeShiftR)
library(raster)
library(rasterVis)
library(viridis)
library(tidyverse)
library(ggplot2) 

# relative path from working directory:
dirpath = &quot;models/BlackGrouse/&quot;

# Create sub-folders (if not already existing)
if(!file.exists(paste0(dirpath,&quot;Inputs&quot;))) {
  dir.create(paste0(dirpath,&quot;Inputs&quot;), showWarnings = TRUE) }
if(!file.exists(paste0(dirpath,&quot;Outputs&quot;))) {
  dir.create(paste0(dirpath,&quot;Outputs&quot;), showWarnings = TRUE) }
if(!file.exists(paste0(dirpath,&quot;Output_Maps&quot;))) {
  dir.create(paste0(dirpath,&quot;Output_Maps&quot;), showWarnings = TRUE) }</code></pre>
<p>Download the input files <a href="data/BlackGrouse_data.zip"><strong>here</strong></a> and put these into the ‘Inputs’ folder.</p>
</div>
<div id="landscape-settings" class="section level2">
<h2><span class="header-section-number">1.2</span> Landscape settings</h2>
<p>The underlying landscape with habitat suitability is derived from a correlative species distribution model (SDM; <span class="citation">Zurell et al. (2020)</span>). Similar to occupancy models, SDMs fit a statistical relationship between the occurrence (or occupancy) probability of a species and environment based on observed presences. In <span class="citation">Zurell et al. (2012)</span>, SDMs were fit to species occurrences observed between 1993-1996 <span class="citation">(Schmid et al. 1998)</span> and to climate data and land use data. Here, we do not use exactly the same maps from the original publication but re-ran the SDMs using newer climate data from the CHELSA climatologies (<a href="https://chelsa-climate.org/" class="uri">https://chelsa-climate.org/</a>) and CORINE land use data (<a href="https://land.copernicus.eu/pan-european/corine-land-cover" class="uri">https://land.copernicus.eu/pan-european/corine-land-cover</a>). We used four different algorithms to fit SDMs (generalised linear models - GLMs, generalised additive models - GAMs, random forests, and boosted regression trees) and build ensembles by averaging predictions over the four different algorithms. All models showed excellent predictive performance (similar to performance measures reported in <span class="citation">Zurell et al. (2012)</span>). For simplicity, we only made future predictions to a single climate change scenario for the period 2061-2080 (based on the CESM1-BGC earth system model and RCP4.5). We then interpolated predicted habitat suitability between 2000 and 2070 in ten-year intervals, and rescaled these to values ranging 0-100 %.</p>
<pre class="r"><code># Read in landscape files
r_lc2000 &lt;- raster(paste0(dirpath,&#39;Inputs/BlackGrouse_SDMpredictions2000.asc&#39;))
r_lc2010 &lt;- raster(paste0(dirpath,&#39;Inputs/BlackGrouse_SDMpredictions2010.asc&#39;))
r_lc2020 &lt;- raster(paste0(dirpath,&#39;Inputs/BlackGrouse_SDMpredictions2020.asc&#39;))
r_lc2030 &lt;- raster(paste0(dirpath,&#39;Inputs/BlackGrouse_SDMpredictions2030.asc&#39;))
r_lc2040 &lt;- raster(paste0(dirpath,&#39;Inputs/BlackGrouse_SDMpredictions2040.asc&#39;))
r_lc2050 &lt;- raster(paste0(dirpath,&#39;Inputs/BlackGrouse_SDMpredictions2050.asc&#39;))
r_lc2060 &lt;- raster(paste0(dirpath,&#39;Inputs/BlackGrouse_SDMpredictions2060.asc&#39;))
r_lc2070 &lt;- raster(paste0(dirpath,&#39;Inputs/BlackGrouse_SDMpredictions2070.asc&#39;))</code></pre>
<p>Each ascii file contains habitat suitability [0..100]. Let’s take a look at these.</p>
<pre class="r"><code># Read in border mask of Switzerland
CH_mask &lt;- raster(paste0(dirpath,&#39;Inputs/CH_mask.grd&#39;))

# For displaying the rasters, we stack them and then mask them using the Swiss border mask
plot(mask(stack(mget(grep(&#39;r_lc&#39;,ls(),value=T))), CH_mask))</code></pre>
<p><img src="RS2_blackgrouse_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>The maps show that black grouse habitat is mainly distributed in the mountains but currently does not stretch right into the alpine zones. Under climate change, habitat is predicted to move uphill.</p>
<p>We want to run simulations under static environmental conditions and under climate change, and thus need to set up two different landscape modules, a static landscape and a dynamic landscape.</p>
<div id="static-landscape" class="section level3">
<h3><span class="header-section-number">1.2.1</span> Static landscape</h3>
<p>The static landscape module only uses the first habitat suitability map for current climate. We use a cell-based model with a 1km resolution and continuous habitat suitability provided in percent quality. We will implement a stage-structured model and, thus, the parameter <code>K_or_DensDep</code> describes the strength of density dependence <em>1/b</em> <span class="citation">(Bocedi et al. 2020; Malchow et al. 2020)</span>. Thereby, <em>b</em> can be interpreted as the area per individual [ha/ind] at which an individual will feel density dependence, meaning the area below which it feels the population is too dense. We initially assume <em>b</em> is 2 ha/ind, meaning that density dependence will hit in if an individual has less than 2 ha of high-quality habitat left. You could also interpret it as the area that the individual will defend as territory and will not allow any conspecifics in. Observed maximum densities of black grouse in the field were reported around 10 ind/km<sup>2</sup> <span class="citation">(Zurell et al. 2012)</span>. Yet, it is less clear what area of their home range they would defend as territory.</p>
<pre class="r"><code># Set static landscape parameters
land &lt;- ImportedLandscape(LandscapeFile = &quot;BlackGrouse_SDMpredictions2000.asc&quot;, 
        Resolution = 1000, # resolution of one grid cell in m
        HabPercent = TRUE, # habitat map includes percentage of suitability
        K_or_DensDep = 0.5) # strength of density dependence 1/b</code></pre>
</div>
<div id="dynamic-landscape" class="section level3">
<h3><span class="header-section-number">1.2.2</span> Dynamic landscape</h3>
<p>In the dynamic landscape module, we have to indicate in which year of the simulation the different landscape maps are used. In line with <span class="citation">Zurell et al. (2012)</span>, we used a spinup period of 25 years during which we simulate population dynamics in the static landscape in order to reduce the effects of initial conditions. Otherwise, we use the same parameters for density dependence as in the static landscape module.</p>
<pre class="r"><code># Numbers of spinup years in dynamic landscape
spinup &lt;- 25

# Set dynamic landscape parameters
land_cc &lt;- ImportedLandscape(LandscapeFile = c(&quot;BlackGrouse_SDMpredictions2000.asc&quot;,
                                               &quot;BlackGrouse_SDMpredictions2010.asc&quot;,
                                               &quot;BlackGrouse_SDMpredictions2020.asc&quot;,
                                               &quot;BlackGrouse_SDMpredictions2030.asc&quot;,
                                               &quot;BlackGrouse_SDMpredictions2040.asc&quot;,
                                               &quot;BlackGrouse_SDMpredictions2050.asc&quot;,
                                               &quot;BlackGrouse_SDMpredictions2060.asc&quot;,
                                               &quot;BlackGrouse_SDMpredictions2070.asc&quot;), 
          DynamicLandYears = c(0, spinup, spinup+10, spinup+20, spinup+30, spinup+40, spinup+50, spinup+60), # years to switch landscapes
          Resolution = 1000, # resolution of one grid cell
          HabPercent = TRUE, # habitat map includes percentage of suitability
          K_or_DensDep = 0.5)  # strength of density dependence 1/b</code></pre>
</div>
</div>
<div id="demography-settings" class="section level2">
<h2><span class="header-section-number">1.3</span> Demography settings</h2>
<p>In black grouse, females are the limiting sex regarding reproduction and dispersal and we hence use an asexual model <span class="citation">(Zurell et al. 2012)</span>. We consider stage structured populations and distinguish two stages, juveniles that will disperse and adult hens that start reproducing at yearling age. Some studies indicate that yearlings produce less offspring then adults <span class="citation">(Caizergues and Ellison 2000)</span> but we here follow the scheduling suggested in <span class="citation">(Zurell et al. 2012)</span>.</p>
<p>The original black grouse model distinguished different clutch sizes, which is not possible in <em>RangeShifter</em>. We, thus, have to average clutch sizes to obtain a mean fecundity. Check out the original parameters in Table 2 of <span class="citation">Zurell et al. (2012)</span> and try to match those parameters with our transition matrix:</p>
<pre class="r"><code># Define transition matrix
(trans_mat &lt;- matrix(c(0, 0.6,1.646,   0.5), nrow = 2, byrow = F)) </code></pre>
<pre><code>##      [,1]  [,2]
## [1,]  0.0 1.646
## [2,]  0.6 0.500</code></pre>
<pre class="r"><code># stage 0 : dispersing juveniles; stage 1: adult, reproducing hens</code></pre>
<p>In the demographic module, we assume that density dependence only acts on survival <span class="citation">(Zurell et al. 2012)</span> and that individuals reach a maximum age of 10 years.</p>
<pre class="r"><code># Define stage structured module
stg &lt;- StageStructure(Stages = 2, # 2 stages
                      TransMatrix = trans_mat,
                      MaxAge = 10,
                      FecDensDep = F , 
                      SurvDensDep = T , # Only mortality increases with density
                      SurvDensCoeff = 1 # Density dependence relative to 1/b
)

# Define demography module
demo &lt;- Demography(StageStruct = stg, ReproductionType = 0) # asexual model</code></pre>
<p>We can quickly check visually how density affects vital rates under the chosen parameterisation:</p>
<pre class="r"><code>plotProbs(stg)</code></pre>
<p><img src="RS2_blackgrouse_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
</div>
<div id="dispersal-settings" class="section level2">
<h2><span class="header-section-number">1.4</span> Dispersal settings</h2>
<p>Dispersal is vital for connecting local populations and typically involves three phases: emigration, transport and settlement. In black grouse, only the juveniles disperse (natal dispersal) with an emigration probability of 0.81. For the transfer phase, we assume a negative exponential dispersal kernel with a mean dispersal distance of 8 km. For the settlement phase, we assume that the individuals can adapt their home range to some extent. Thus, if an individual arrives in an unsuitable cell, it can randomly choose a suitable cell within its 8-cell neighbourhood or will die.</p>
<pre class="r"><code># Define dispersal module
disp &lt;-  Dispersal(
  # Emigration phase: stage 0 has constant emigration probability of 0.81
  Emigration = Emigration(StageDep=T, EmigProb = cbind(0:1,c(0.81,0)) ),
  # Transfer phase: negative exponential dispersal kernel with mean dispersal distance of 8km
  Transfer = DispersalKernel(Distances = 8000),
  # Settlement: if individual arrives in unsuitable cells, it can randomly chose a suitable neighbouring cell or will die
  Settlement = Settlement(Settle = 2) 
  )</code></pre>
</div>
<div id="initialisation-settings" class="section level2">
<h2><span class="header-section-number">1.5</span> Initialisation settings</h2>
<p>At initialisation, we randomly distribute 8000 individuals in suitable habitat with random age (&gt;1 year). Remember that habitat suitability is provided in the landscape maps and derived from a species distribution model.</p>
<pre class="r"><code># Define initial conditions for simulations
init &lt;- Initialise( InitType = 0, FreeType = 0, NrCells = 8000, # free initialization in 8000 random cells 
                    InitDens = 2, # start population at given density (in individuals per cell; next line)
                    IndsHaCell = 1, # set initial density to 2 inds/cell
                    PropStages = c(0, 1) # we initialise only adult hens
)</code></pre>
</div>
<div id="simulation-settings" class="section level2">
<h2><span class="header-section-number">1.6</span> Simulation settings</h2>
<p>In the simulation module, we specify the length of simulation, environmental stochasticity, and the output types. We want to run the model for 100 years after an initial spin-up phase of 25 years. The spin-up phase is important to exclude any initialisation effects. For illustrative purposes, we only simulate 10 replicates here. Typically, you would use around 100 replicates to capture the effects of demographic and environmental stochasticity.</p>
<p>We assume that local environmental stochasticity acts on fecundity. This is slightly different from <span class="citation">Zurell et al. (2012)</span> where environmental stochasticity acted <em>pleadYoung</em> (the probability of a hen to produce offspring). We assume that environmental stochasticity is independent between cells and years (local, and without temporal autocorrelation). Last, we set the control parameters for the output files, specifying that output should be generated each year.</p>
<pre class="r"><code># Set the number of replicate simulations to run - for quick illustration, we use few replicates here, typically should be &gt;20 
RepNb &lt;- 10
sim_years &lt;- 100</code></pre>
<pre class="r"><code>sim &lt;- Simulation(Simulation = 0, 
                  Replicates = RepNb, # number of replicates to be run
                  Years = spinup + sim_years, # number of years to be simulated
                  EnvStoch = 2, #include local environmental stochasticity
                  EnvStochType = 0,  # Environmental Stochasticity included in fecundity (in Zurell et al. 2012, in pleadYoung)
                  std=0.15,minR=1.28,maxR=2.53, # standard deviation defined to correspond roughly to pleadYoung variability in Zurell et al. (2012)
                  ac=0, # no temporal autocorrelation
                  OutIntPop = 1,
                  OutIntOcc = 1,
                  OutIntRange = 1)</code></pre>
</div>
<div id="parameter-master" class="section level2">
<h2><span class="header-section-number">1.7</span> Parameter master</h2>
<p>We put together the paramaters master with all the model settings. For ease of replicability, we set a seed for the random number generator so that you should get the same results as shown in this practical here. Typically, we would use a random seed.</p>
<pre class="r"><code># RangeShifter parameter master object for static landscape (we set a seed for replicable results)
s &lt;- RSsim(batchnum = 1, land = land, demog = demo, dispersal = disp, simul = sim, init = init, seed = 324135)</code></pre>
<p>The settings for the baseline scenario (in static landscape) and for the climate change scenario only differ in the landscape module. Additionally, we define a different <code>batchnum</code> to avoid overwriting any output files.</p>
<pre class="r"><code># RangeShifter parameter master object for dynamic landscape
s_cc &lt;- RSsim(batchnum = 2, land = land_cc, demog = demo, dispersal = disp, simul = sim, init = init, seed = 324135)</code></pre>
</div>
</div>
<div id="simulating-population-and-range-dynamics" class="section level1">
<h1><span class="header-section-number">2</span> Simulating population and range dynamics</h1>
<p>Everything is prepared for running the simulations.</p>
<div id="population-dynamics-under-current-climate" class="section level2">
<h2><span class="header-section-number">2.1</span> Population dynamics under current climate</h2>
<p>We first simulate black grouse population dynamics under current climate (using the static landscape). By default, you will see some output in the console on the simulation progress. Depending on your machine the simulations could take &gt;2 minutes.</p>
<pre class="r"><code># Run simulations with 25 years spin up
RunRS(s, dirpath)</code></pre>
<p>First, we want to get a quick impression of the simulated population dynamics and take a look at mean abundances and mean number of occupied cells over all replicate runs.</p>
<pre class="r"><code># plot the resulting abundances and occupancy
par(mfrow=c(1,2))

# Abundances
plotAbundance(s, dirpath)

# Occupancy
plotOccupancy(s, dirpath)</code></pre>
<p><img src="RS2_blackgrouse_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>Next, we would like to map mean population abundance in space. For this, we have to post-process the <code>RangeShiftR</code> output. We will use the <code>tidyverse</code> family for data manipulation, more specifically functions from the <code>dplyr</code> package. The construct <code>%&gt;%</code>is a pipe, which feeds output from one function into the first argument of the next function. This way, multiple computing steps can be chained together easily.</p>
<p>The population output file contains the number of individuals in each occupied cell per year and replicate. We take this dataframe and calculate the mean abundances per cell and specific years (here, year 25 after spin-up and year 125 at end of simulation) over all replicates.</p>
<pre class="r"><code># Map mean abundances

# Read population output file into a data frame
pop_static &lt;- readPop(s, dirpath)

# Make data frame with mean abundances per cell and selected year:
pop_static_wide &lt;- pop_static %&gt;%
  # Select years you want to map
  filter(Year %in% c(spinup, spinup+sim_years) ) %&gt;%
  # Define grouping variables
  group_by(x,y,Year) %&gt;%
  # Average individuals over replicate runs
  summarise(meanInd = mean(NInd)) %&gt;%
  # Make separate columns for different years
  pivot_wider(names_from=Year, values_from=meanInd)

pop_static_wide</code></pre>
<pre><code>## # A tibble: 8,580 x 4
## # Groups:   x, y [8,580]
##        x     y  `25` `125`
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 63500 57500   0.5   0.3
##  2 63500 58500   0.2   0.1
##  3 63500 60500   0.6   1  
##  4 64500 36500   0.1   0.3
##  5 64500 57500   0.5   0.2
##  6 64500 58500   0.1   0  
##  7 65500 35500   0.3   0.3
##  8 65500 36500   0.2   0  
##  9 65500 37500   0     0  
## 10 65500 38500   0.4   0.3
## # … with 8,570 more rows</code></pre>
<p>Next, we make raster maps from the selected output years. Thereby, we have to take care that the coordinates are in the same format as the original input map to ease mapping and allow masking to the Swiss borders.</p>
<pre class="r"><code># Make raster stacks

# Transfer into correct coordinate system
pop_static_wide$x &lt;- pop_static_wide$x + xmin(CH_mask)
pop_static_wide$y &lt;- pop_static_wide$y + ymin(CH_mask)

# Make raster stack
r_pop_static &lt;- rasterFromXYZ(pop_static_wide, crs=crs(CH_mask))
# Extend to original spatial extent
r_pop_static &lt;- extend(r_pop_static, CH_mask)
# Change names
names(r_pop_static) &lt;- sub(&#39;X&#39;,&#39;Year.&#39;,names(r_pop_static))
# Set empty cells within Switzerland to zero (instead of NA)
values(r_pop_static)[!is.na(values(CH_mask))&amp;is.na(values(r_pop_static))] &lt;- 0

# Map (while masking to Swiss borders)
plot(mask(r_pop_static, CH_mask))</code></pre>
<p><img src="RS2_blackgrouse_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>Both maps should look very similar as we simulated populations at equilibrium and thus expect that the mean population abundances are constant around a mean (as we also saw in the abundance time series plot above.</p>
</div>
<div id="population-dynamics-under-future-climate" class="section level2">
<h2><span class="header-section-number">2.2</span> Population dynamics under future climate</h2>
<p>Let’s now simulate the population dynamics under climate change. Remember that for simplicity we have only chosen a single climate scenario. Typically, you should compare climate scenarios from different climate models and potentially also consider different emission pathways (“Representative Concentration Pathways”).</p>
<pre class="r"><code># Run simulations with 25 years spin up
RunRS(s_cc, dirpath)</code></pre>
<p>Again, we plot mean abundance and mean number of occupied cells over time. In contrast to the original study by <span class="citation">Zurell et al. (2012)</span> our model predicts a strong increase in black grouse abundance under climate change. This could have several reasons related to the different model implementation and settings (e.g. differences in how density dependence is treated in <code>RangeShiftR</code> and in the original model), the different underlying input datasets for the SDMs and the different climate scenarios based on newer climate model generations <span class="citation">(Knutti, Masson, and Gettelman 2013)</span>.</p>
<pre class="r"><code># plot the resulting abundances and occupancy
par(mfrow=c(1,2))

# Abundances
plotAbundance(s_cc, dirpath)

# Occupancy
plotOccupancy(s_cc, dirpath)</code></pre>
<p><img src="RS2_blackgrouse_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<p>Similar to above, we calculate mean abundance per cell over all replicates, but now do so for every 10-year interval after the spin-up phase to map the simulated range dynamics.</p>
<pre class="r"><code># Read population output file into a data frame
pop_dynamic &lt;- readPop(s_cc, dirpath)

# Make data frame with mean abundances per cell and selected year:
pop_dynamic_wide &lt;- pop_dynamic %&gt;%
  # Select years you want to map: every ten years after spinup
  filter(Year %in% c(spinup, spinup+seq(10,sim_years,by=10)) ) %&gt;%
  # Define grouping variables
  group_by(x,y,Year) %&gt;%
  # Average individuals over replicate runs
  summarise(meanInd = mean(NInd), .groups=&#39;keep&#39;) %&gt;%
  # Make separate columns for different years
  pivot_wider(names_from=Year, values_from=meanInd)</code></pre>
<pre class="r"><code># Make raster stacks

# Transfer into correct coordinate system
pop_dynamic_wide$x &lt;- pop_dynamic_wide$x + xmin(CH_mask)
pop_dynamic_wide$y &lt;- pop_dynamic_wide$y + ymin(CH_mask)

# Make raster stack
r_pop_dynamic &lt;- rasterFromXYZ(pop_dynamic_wide, crs=crs(CH_mask))
# Extend to original spatial extent
r_pop_dynamic &lt;- extend(r_pop_dynamic, CH_mask)
# Change names
names(r_pop_dynamic) &lt;- sub(&#39;X&#39;,&#39;Year.&#39;,names(r_pop_dynamic))
# Set empty cells within Switzerland to zero (instead of NA)
values(r_pop_dynamic)[!is.na(values(CH_mask))&amp;is.na(values(r_pop_dynamic))] &lt;- 0

# Map
plot(mask(r_pop_dynamic, CH_mask))</code></pre>
<p><img src="RS2_blackgrouse_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<p>Under current climate, black grouse is predicted to be present across the entire alpine region although the high mountain ridges were not predicted to be occupied, and highest occupancy was simulated in Ticino region. Under climate change, the population is predicted to increase strongly and expands its range uphill towards the mountain tops. Towards the end of the simulation, highest mean abundances are predicted for the Grisons and Ticino regions.</p>
</div>
</div>
<div id="sensitivity-analysis" class="section level1">
<h1><span class="header-section-number">3</span> Sensitivity analysis</h1>
<p>Sensitivity analyses are important to understand the major sources of uncertainty. <span class="citation">Zurell et al. (2012)</span> studied different sources of uncertainity including the underlying SDMs, climate scenarios and demographic parameters. Here, we exemplarily test the sensitivity against one vital rate and against density dependence assumptions.</p>
<div id="change-vital-rates" class="section level2">
<h2><span class="header-section-number">3.1</span> Change vital rates</h2>
<p>We use a local sensitivity analysis to test the effect of varying demographic parameter values on the simulation results. Specifically, we vary the adult survival probability (<em>pSurv</em>) by -/+ 5%. To do so, we have to change the transition matrix, the <code>StageStructure</code> submodule, the <code>Demography</code> module and, finally, we have to set up a new parameter master object.</p>
<pre class="r"><code># We reduce juvenile survival
(trans_mat2 &lt;- matrix(c(0, 0.6,1.646,   0.45), nrow = 2, byrow = F)) </code></pre>
<pre><code>##      [,1]  [,2]
## [1,]  0.0 1.646
## [2,]  0.6 0.450</code></pre>
<pre class="r"><code># Define stage structured module
stg2 &lt;- StageStructure(Stages = 2, # 2 stages plus stage 0
                      TransMatrix = trans_mat2,
                      MaxAge = 10,
                      FecDensDep = F , 
                      SurvDensDep = T , # Only mortality increases with density
                      SurvDensCoeff = 1 # Density dependence relative to 1/b
)

# Define demography module
demo2 &lt;- Demography(StageStruct = stg2, ReproductionType = 0) # asexual model

# Set new parameter master object for static landscape
s2 &lt;- RSsim(batchnum = 12, land = land, demog = demo2, dispersal = disp, simul = sim, init = init, seed = 324135)</code></pre>
<p>We can then run the simulations for lower adult survival probabilities <code>pSurv=0.45</code> and plot the resulting population dynamics.</p>
<pre class="r"><code># Run simulations
RunRS(s2, dirpath)</code></pre>
<pre class="r"><code># plot the resulting abundances and occupancy
par(mfrow=c(1,2))
plotAbundance(s2, dirpath)
plotOccupancy(s2, dirpath)</code></pre>
<p><img src="RS2_blackgrouse_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<p>We follow the same procedure to run a scenarios with increased adult survival probabilities <code>pSurv=0.55</code>.</p>
<pre class="r"><code># We reduce juvenile survival
(trans_mat3 &lt;- matrix(c(0, 0.6,1.646,   0.55), nrow = 2, byrow = F)) </code></pre>
<pre><code>##      [,1]  [,2]
## [1,]  0.0 1.646
## [2,]  0.6 0.550</code></pre>
<pre class="r"><code># Define stage structured module
stg3 &lt;- StageStructure(Stages = 2, # 2 stages plus stage 0
                      TransMatrix = trans_mat3,
                      MaxAge = 10,
                      FecDensDep = F , 
                      SurvDensDep = T , # Only mortality increases with density
                      SurvDensCoeff = 1 # Density dependence relative to 1/b
)

# Define demography module
demo3 &lt;- Demography(StageStruct = stg3, ReproductionType = 0) # asexual model

# Set new parameter master object for static landscape
s3 &lt;- RSsim(batchnum = 13, land = land, demog = demo3, dispersal = disp, simul = sim, init = init, seed = 324135)</code></pre>
<pre class="r"><code># Run simulations
RunRS(s3, dirpath)</code></pre>
<pre class="r"><code># plot the resulting abundances and occupancy
par(mfrow=c(1,2))
plotAbundance(s3, dirpath)
plotOccupancy(s3, dirpath)</code></pre>
<p><img src="RS2_blackgrouse_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<p>As result, a decrease in adult survival probability leads to reduced population sizes. However, in contrast to <span class="citation">Zurell et al. (2012)</span> the population does not go extinct. Thus, the <code>RangeShiftR</code> implementation and simulations seem to be slightly less sensitive to changes in vital rates.</p>
</div>
<div id="change-density-dependence-settings" class="section level2">
<h2><span class="header-section-number">3.2</span> Change density dependence settings</h2>
<p>As mentioned in the landscape settings, observed density in black grouse has been reported to be up to 10 individuals per km<sup>2</sup>. Yet, typically this is not directly comparable to the density parameter <em>1/b</em> where <em>b</em> can rather be interpreted as the territory size that an individual will defend against conspecifics. Initially, we assumed <code>1/b=0.5</code>, meaning that an individual will defend a territory of 2 ha. As part of the sensitivity analyses, we now want to test the effect of larger territory size. With up to 10 individuals observed per km<sup>2</sup>, the maximum size if high-quality habitat that an individual will defend should be 10 ha. We thus set <code>1/b=0.1</code>.</p>
<p>We have to specify a new landscape module and have to update the parameter master.</p>
<pre class="r"><code># Set static landscape parameters
land2 &lt;- ImportedLandscape(LandscapeFile = &quot;BlackGrouse_SDMpredictions2000.asc&quot;, 
        Resolution = 1000, # resolution of one grid cell in m
        HabPercent = TRUE, # habitat map includes percentage of suitability
        K_or_DensDep = 0.1) # strength of density dependence 1/b

# Set new parameter master object for static landscape
s4 &lt;- RSsim(batchnum = 14, land = land2, demog = demo, dispersal = disp, simul = sim, init = init, seed = 324135)</code></pre>
<pre class="r"><code># Run simulations
RunRS(s4, dirpath)</code></pre>
<pre class="r"><code># plot the resulting abundances and occupancy
par(mfrow=c(1,2))
plotAbundance(s4, dirpath)
plotOccupancy(s4, dirpath)</code></pre>
<p><img src="RS2_blackgrouse_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
<p>When larger territories are defended, individuals experience a stronger effect of density dependence. In our simulations, this leads to extinction of the entire population.</p>
</div>
<div id="compare-scenarios" class="section level2">
<h2><span class="header-section-number">3.3</span> Compare scenarios</h2>
<p>Finally, let’s look at all results from the sensitivity analyses and compare the predicted abundances.</p>
<pre class="r"><code># Join mean (and sd) of abundances over all static scenarios in a single data frame
abund_sens &lt;- bind_rows(
  # Scenario static 1:
  # The function readRange() runs in the background of plotAbundance(). Here, we extract abundances per scenario by hand.
  readRange(s,dirpath) %&gt;%
    group_by(Year) %&gt;%
    summarise(Abundance = mean(NInds), sd = sd(NInds)) %&gt;% add_column(Scenario = &quot;1 - Default&quot;), 
  # Scenario static 2
  readRange(s2,dirpath) %&gt;%
    group_by(Year) %&gt;%
    summarise(Abundance = mean(NInds), sd = sd(NInds)) %&gt;% add_column(Scenario = &quot;2 - AdultSurv -5%&quot;), 
  # Scenario static 3
  readRange(s3,dirpath) %&gt;%
    group_by(Year) %&gt;%
    summarise(Abundance = mean(NInds), sd = sd(NInds)) %&gt;% add_column(Scenario = &quot;3 - AdultSurv +5%&quot;),
  # Scenario static 4
  readRange(s4,dirpath) %&gt;%
    group_by(Year) %&gt;%
    summarise(Abundance = mean(NInds), sd = sd(NInds)) %&gt;% add_column(Scenario = &quot;4 - TerritorySize * 5&quot;)) 

# Plot abundance
ggplot(data = abund_sens, mapping = aes(x = Year, y = log(Abundance),  color=Scenario)) + 
  geom_line(size=2) +
  geom_ribbon(aes(ymin=log(Abundance-sd), ymax=log(Abundance+sd)), linetype=2, alpha=0.1)</code></pre>
<p><img src="RS2_blackgrouse_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
</div>
</div>
<div id="extinction-risk-and-mean-time-to-extinction" class="section level1">
<h1><span class="header-section-number">4</span> Extinction risk and mean time to extinction</h1>
<p><span class="citation">Zurell et al. (2012)</span> calculated extinction risk and compared this across different scenarios. Above, we can already see that the population is not going extinct in most of our selected scenarios. Nevertheless, we show here how extinction risk and mean time to extinction can be derived.</p>
<p>Extinction probability at a specific time can be defined as the proportion of replicate simulation runs without viable population at a specific point in time. We can extract this information from the population output file.</p>
<pre class="r"><code># Calculate survival probability as number of replicate with surviving individuals per year

# Extinction probability in static landscape simulation:
extProb_static &lt;- pop_static %&gt;%
  group_by(Rep,Year) %&gt;%
  # Sum individuals over all cells per year and replicate
  summarise(sumPop = sum(NInd), .groups=&#39;keep&#39;) %&gt;%
  group_by(Year) %&gt;%
  # Average extinction probability (1 minus the proportion of replicates with surviving populations)
  summarise(extProb = 1-sum(sumPop&gt;0, na.rm=T)/RepNb)

# As the population did not go extinct, the extinction probability is zero throughout the entire simulation
extProb_static$extProb</code></pre>
<pre><code>##   [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
##  [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
##  [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [112] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</code></pre>
<p>Accordingly, the mean time to extinction can then be defined as the mean time across all replicates when the population went extinct. Again, this information can be extracted from the population output file.</p>
<pre class="r"><code># Mean time to extinction in static landscape simulation:
extTime_static &lt;- pop_static %&gt;%
  group_by(Rep,Year) %&gt;%
  # Sum individuals over all cells per year and replicate    
  summarise(sumPop = sum(NInd), .groups=&#39;keep&#39;) %&gt;% 
  # Identify in which year they go extinct
  filter(sumPop==0) %&gt;% 
  pull(Year) %&gt;% mean

# As the population did not go extinct, the mean time to extinction is unknown
extTime_static</code></pre>
<pre><code>## [1] NaN</code></pre>
<p>As the computation of these measures takes a few line of code, it is useful to define an own function to ease computation and keep our R script as short as possible. We thus define two new functions (using the construct <code>function()</code>) for calculating extinction probability and mean time to extinction.</p>
<pre class="r"><code># Define a function for calculating extinction probability
Calc_ExtProb &lt;- function(pop_df,s) {
  require(dplyr)
  
  pop_df %&gt;%
  group_by(Rep,Year) %&gt;%
  # Sum individuals over all cells per year and replicate
  summarise(sumPop = sum(NInd), .groups=&#39;keep&#39;) %&gt;%
  group_by(Year) %&gt;%
  # Average extinction probability (1 minus the proportion of replicates with surviving populations)
  summarise(extProb = 1-sum(sumPop&gt;0, na.rm=T)/RepNb) %&gt;%
  # Make sure that data frame is filled until last year of simulation
  right_join(tibble(Year = seq_len(s@simul@Years)), by=&#39;Year&#39;) %&gt;% replace_na(list(extProb=1))
}

# Define a function for calculating mean time to extinction
Calc_ExtTime &lt;- function(pop_df) {
  require(dplyr)
  
  pop_df %&gt;%
  group_by(Rep,Year) %&gt;%
  # Sum individuals over all cells per year and replicate    
  summarise(sumPop = sum(NInd), .groups=&#39;keep&#39;) %&gt;% 
  # Identify in which year they go extinct
  filter(sumPop==0) %&gt;% 
  pull(Year) %&gt;% mean
}</code></pre>
<p>Once loaded into your R console, these functions can be used just as any other function from the different packages. Let’s use our new functions to calculate extinction probability and mean time to extinction for all the different scenarios.</p>
<pre class="r"><code># Extinction probability &amp; mean time to extinction in dynamic landscape simulation:
extProb_dynamic&lt;- Calc_ExtProb(pop_dynamic, s_cc) 
extTime_dynamic &lt;- Calc_ExtTime(pop_dynamic)

# Extinction probability &amp; mean time to extinction for different scenarions in sensitivity analyses:
# Scenario: AdultSurvival -5%
pop_static2 &lt;- readPop(s2, dirpath)
extProb_static2 &lt;- Calc_ExtProb(pop_static2, s2)
extTime_static2 &lt;- Calc_ExtTime(pop_static2)

# Scenario: AdultSurvival +5%
pop_static3 &lt;- readPop(s3, dirpath)
extProb_static3 &lt;- Calc_ExtProb(pop_static3, s3)
extTime_static3 &lt;- Calc_ExtTime(pop_static3)

# Scenario: TerritorySize *5
pop_static4 &lt;- readPop(s4, dirpath)
extProb_static4 &lt;- Calc_ExtProb(pop_static4, s4)
(extTime_static4 &lt;- Calc_ExtTime(pop_static4))</code></pre>
<pre><code>## [1] 66.6</code></pre>
<p>We already know from looking at the abundance time series that the population only went extinct in our <em>Territory size *5</em> scenario. Thus, our <code>Calc_ExtTime()</code> function will only produce a meaningful mean time to extinction for this scenario. Plotting the extinction probability over time provides a nice visual means to understand mean time to extinction.</p>
<pre class="r"><code># Join extinction probabilities in a single data frame
extProb_sens &lt;- bind_rows(extProb_static %&gt;% add_column(Scenario = &quot;1 - Default&quot;),
                    extProb_dynamic %&gt;% add_column(Scenario = &quot;2 - Default + climate change&quot;),      
                    extProb_static2 %&gt;% add_column(Scenario = &quot;3 - AdultSurv -5%&quot;), 
                    extProb_static3 %&gt;% add_column(Scenario = &quot;4 - AdultSurv +5%&quot;),
                    extProb_static4 %&gt;% add_column(Scenario = &quot;5 - TerritorySize *5&quot;))


# Plot extinction probabilities
ggplot(data = extProb_sens, mapping = aes(x = Year, y = extProb, color=Scenario)) + 
  geom_line(size=2) +
  ylim(0,1)</code></pre>
<p><img src="RS2_blackgrouse_files/figure-html/unnamed-chunk-39-1.png" width="672" /></p>
<p>Note that in the current example, extinction probabilities are non-zero only for the static scenario with increased territory size while all other scenarios have zero extinction probability.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-Bocedi2020">
<p>Bocedi, G., S. C. F. Palmer, A.-K. Malchow, D. Zurell, K. Watts, and J. M. J. Travis. 2020. “RangeShifter 2.0: An Extended and Enhanced Platform for Modelling Spatial Eco-Evolutionary Dynamics and Species’ Responses to Environmental Changes.” <em>bioRxiv</em>, 2020.11.26.400119. <a href="https://doi.org/10.1101/2020.11.26.400119">https://doi.org/10.1101/2020.11.26.400119</a>.</p>
</div>
<div id="ref-Bocedi2014">
<p>Bocedi, G., S.C.F. Palmer, G. Pe’er, R.K. Heikkinen, Y.G. Matsinos, K. Watts, and J.M.J. Travis. 2014. “RangeShifter: A Platform for Modelling Spatial Eco-Evolutionary Dynamics and Species’ Responses to Environmental Changes.” <em>Methods in Ecology and Evolution</em> 5 (4): 388–96. <a href="https://doi.org/10.1111/2041-210X.12162">https://doi.org/10.1111/2041-210X.12162</a>.</p>
</div>
<div id="ref-caizer2000">
<p>Caizergues, A., and L. N. Ellison. 2000. “Age-Specific Reproductive Performance of Black Grouse Tetrao Tetrix Females.” <em>Bird Study</em> 47: 344–51. <a href="https://www.tandfonline.com/doi/pdf/10.1080/00063650009461194">https://www.tandfonline.com/doi/pdf/10.1080/00063650009461194</a>.</p>
</div>
<div id="ref-Knutti_2013">
<p>Knutti, R., D. Masson, and A. Gettelman. 2013. “Climate Model Genealogy: Generation CMIP5 and How We Got There.” <em>Geophysical Research Letters</em> 40 (6). American Geophysical Union (AGU): 1194–9. <a href="https://doi.org/10.1002/grl.50256">https://doi.org/10.1002/grl.50256</a>.</p>
</div>
<div id="ref-Malchow2020">
<p>Malchow, A.K., G. Bocedi, S. C. F. Palmer, J. M. J. Travis, and D. Zurell. 2020. “RangeShiftR: An R Package for Individual-Based Simulation of Spatial Eco-Evolutionary Dynamics and Species’ Responses to Environmental Change.” <em>bioRxiv</em>, 2020.11.17.384545. <a href="https://doi.org/10.1101/2020.11.17.384545">https://doi.org/10.1101/2020.11.17.384545</a>.</p>
</div>
<div id="ref-Schmid1998">
<p>Schmid, H., R. Luder, B. Naef-Daenzer, R. Graf, and N. Zbinden. 1998. <em>Schweizer Brutvogelatlas. Verbreitung Der Brutvögel in Der Schweiz Und Im Fürstentum Liechtenstein 1993-1996</em>. Swiss Ornithological Institute, Sempach, Switzerland.</p>
</div>
<div id="ref-Zurell2020">
<p>Zurell, D., J. Franklin, C. König, P. J. Bouchet, C. F. Dormann, J. Elith, G. Fandos, et al. 2020. “A Standard Protocol for Reporting Species Distribution Models.” <em>Ecography</em> 43 (9): 1261–77. <a href="https://doi.org/10.1111/ecog.04960">https://doi.org/10.1111/ecog.04960</a>.</p>
</div>
<div id="ref-Zurell2012a">
<p>Zurell, D., V. Grimm, E. Rossmanith, N. Zbinden, N.E. Zimmermann, and B. Schröder. 2012. “Uncertainty in Predictions of Range Dynamics: Black Grouse Climbing the Swiss Alps.” <em>Ecography</em> 35 (7): 590–603. <a href="https://doi.org/10.1111/j.1600-0587.2011.07200.x">https://doi.org/10.1111/j.1600-0587.2011.07200.x</a>.</p>
</div>
</div>
</div>

<!DOCTYPE html>
<html>

<br>
<hr />
<div id="footer">
<p>Damaris Zurell, Anne-Kathleen Malchow, Jette Reeg 2021 <a href="http://creativecommons.org/licenses/by/4.0/" >(CC BY 4.0)</a>.  </p>
</div>

</html>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
